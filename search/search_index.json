{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"wg-access-server \u00b6 wg-access-server is a single binary that provides a WireGuard VPN server and device management web ui. We support user authentication, 1 click device registration that works with Mac, Linux, Windows, Ios and Android including QR codes. You can configure different network isolation modes for better control and more. This project aims to deliver a simple VPN solution for developers, homelab enthusiasts and anyone else feeling adventurous. wg-access-server is a functional but young project. Contributions are welcome! Documentation \u00b6 See our documentation website Quick Links: Configuration Overview Deploy With Docker Deploy With Helm Deploy With Docker-Compose Running with Docker \u00b6 Here's a quick command to run the server to try it out. export WG_ADMIN_PASSWORD = \"example\" export WG_WIREGUARD_PRIVATE_KEY = \" $( wg genkey ) \" docker run \\ -it \\ --rm \\ --cap-add NET_ADMIN \\ --device /dev/net/tun:/dev/net/tun \\ -v wg-access-server-data:/data \\ -e \"WG_ADMIN_PASSWORD= $WG_ADMIN_PASSWORD \" \\ -e \"WG_WIREGUARD_PRIVATE_KEY= $WG_WIREGUARD_PRIVATE_KEY \" \\ -p 8000 :8000/tcp \\ -p 51820 :51820/udp \\ place1/wg-access-server If you open your browser using your LAN ip address you can even connect your phone to try it out: for example, i'll open my browser at http://192.168.0.XX:8000 using the local LAN IP address. You can connect to the web server on the local machine browser at http://localhost:8000 Running on Kubernetes via Helm \u00b6 wg-access-server ships a Helm chart to make it easy to get started on Kubernetes. Here's a quick start, but you can read more at the Helm Chart Deployment Docs # deploy helm install my-release --repo https://place1.github.io/wg-access-server wg-access-server # cleanup helm delete my-release Running with Docker-Compose \u00b6 Download the the docker-compose.yml file from the repo and run the following command. export WG_ADMIN_PASSWORD = \"example\" export WG_WIREGUARD_PRIVATE_KEY = \" $( wg genkey ) \" docker-compose up You can connect to the web server on the local machine browser at http://localhost:8000 If you open your browser to your machine's LAN IP address you'll be able to connect your phone using the UI and QR code! Screenshots \u00b6 Changelog \u00b6 See the CHANGELOG.md file Development \u00b6 The software is made up a Golang Server and React App. Here's how I develop locally: run cd website && npm install && npm start to get the frontend running on :3000 run sudo go run ./main.go to get the server running on :8000 Here are some notes about the development configuration: sudo is required because the server uses iptables/ip to configure the VPN networking you'll access the website on :3000 and it'll proxy API requests to :8000 thanks to webpack in-memory storage and generated wireguard keys will be used GRPC codegeneration: The client communicates with the server via gRPC-Web. You can edit the API specification in ./proto/*.proto . After changing a service or message definition you'll want to re-generate server and client code using: ./codegen.sh .","title":"Home"},{"location":"#wg-access-server","text":"wg-access-server is a single binary that provides a WireGuard VPN server and device management web ui. We support user authentication, 1 click device registration that works with Mac, Linux, Windows, Ios and Android including QR codes. You can configure different network isolation modes for better control and more. This project aims to deliver a simple VPN solution for developers, homelab enthusiasts and anyone else feeling adventurous. wg-access-server is a functional but young project. Contributions are welcome!","title":"wg-access-server"},{"location":"#documentation","text":"See our documentation website Quick Links: Configuration Overview Deploy With Docker Deploy With Helm Deploy With Docker-Compose","title":"Documentation"},{"location":"#running-with-docker","text":"Here's a quick command to run the server to try it out. export WG_ADMIN_PASSWORD = \"example\" export WG_WIREGUARD_PRIVATE_KEY = \" $( wg genkey ) \" docker run \\ -it \\ --rm \\ --cap-add NET_ADMIN \\ --device /dev/net/tun:/dev/net/tun \\ -v wg-access-server-data:/data \\ -e \"WG_ADMIN_PASSWORD= $WG_ADMIN_PASSWORD \" \\ -e \"WG_WIREGUARD_PRIVATE_KEY= $WG_WIREGUARD_PRIVATE_KEY \" \\ -p 8000 :8000/tcp \\ -p 51820 :51820/udp \\ place1/wg-access-server If you open your browser using your LAN ip address you can even connect your phone to try it out: for example, i'll open my browser at http://192.168.0.XX:8000 using the local LAN IP address. You can connect to the web server on the local machine browser at http://localhost:8000","title":"Running with Docker"},{"location":"#running-on-kubernetes-via-helm","text":"wg-access-server ships a Helm chart to make it easy to get started on Kubernetes. Here's a quick start, but you can read more at the Helm Chart Deployment Docs # deploy helm install my-release --repo https://place1.github.io/wg-access-server wg-access-server # cleanup helm delete my-release","title":"Running on Kubernetes via Helm"},{"location":"#running-with-docker-compose","text":"Download the the docker-compose.yml file from the repo and run the following command. export WG_ADMIN_PASSWORD = \"example\" export WG_WIREGUARD_PRIVATE_KEY = \" $( wg genkey ) \" docker-compose up You can connect to the web server on the local machine browser at http://localhost:8000 If you open your browser to your machine's LAN IP address you'll be able to connect your phone using the UI and QR code!","title":"Running with Docker-Compose"},{"location":"#screenshots","text":"","title":"Screenshots"},{"location":"#changelog","text":"See the CHANGELOG.md file","title":"Changelog"},{"location":"#development","text":"The software is made up a Golang Server and React App. Here's how I develop locally: run cd website && npm install && npm start to get the frontend running on :3000 run sudo go run ./main.go to get the server running on :8000 Here are some notes about the development configuration: sudo is required because the server uses iptables/ip to configure the VPN networking you'll access the website on :3000 and it'll proxy API requests to :8000 thanks to webpack in-memory storage and generated wireguard keys will be used GRPC codegeneration: The client communicates with the server via gRPC-Web. You can edit the API specification in ./proto/*.proto . After changing a service or message definition you'll want to re-generate server and client code using: ./codegen.sh .","title":"Development"},{"location":"2-configuration/","text":"Configuration \u00b6 You can configure wg-access-server using environment variables, cli flags or a config file taking precedence over one another in that order. The default configuration should work out of the box if you're just looking to try it out. The only required configuration is an admin password and a wireguard private key. The admin password can be anything you like. You can generate a wireguard private key by following the official docs . TLDR: wg genkey The config file format is yaml and an example is provided below . Here's what you can configure: Environment Variable CLI Flag Config File Path Required Default (docker) Description WG_CONFIG --config The path to a wg-access-server config.yaml file WG_LOG_LEVEL --log-level logLevel info The global log level WG_ADMIN_USERNAME --admin-username adminUsername admin The admin account username WG_ADMIN_PASSWORD --admin-password adminPassword Yes The admin account password WG_PORT --port port 8000 The port the web ui will listen on (http) WG_EXTERNAL_HOST --external-host externalHost The external domain for the server (e.g. https://www.mydomain.com) WG_STORAGE --storage storage sqlite3:///data/db.sqlite3 A storage backend connection string. See storage docs WG_DISABLE_METADATA --disable-metadata disableMetadata false Turn off collection of device metadata logging. Includes last handshake time and RX/TX bytes only. WG_WIREGUARD_ENABLED --[no-]wireguard-enabled wireguard.enabled true Enable/disable the wireguard server. Useful for development on non-linux machines. WG_WIREGUARD_INTERFACE --wireguard-interface wireguard.interface wg0 The wireguard network interface name WG_WIREGUARD_PRIVATE_KEY --wireguard-private-key wireguard.privateKey Yes The wireguard private key. This value is required and must be stable. If this value changes all devices must re-register. WG_WIREGUARD_PORT --wireguard-port wireguard.port 51820 The wireguard server port (udp) WG_VPN_CIDR --vpn-cidr vpn.cidr 10.44.0.0/24 The VPN network range. VPN clients will be assigned IP addresses in this range. WG_VPN_GATEWAY_INTERFACE --vpn-gateway-interface vpn.gatewayInterface default gateway interface (e.g. eth0) The VPN gateway interface. VPN client traffic will be forwarded to this interface. WG_VPN_ALLOWED_IPS --vpn-allowed-ips vpn.allowedIPs 0.0.0.0/1, 128.0.0.0/1 Allowed IPs that clients may route through this VPN. This will be set in the client's WireGuard connection file and routing is also enforced by the server using iptables. WG_DNS_ENABLED --[no-]dns-enabled dns.enabled true Enable/disable the embedded DNS proxy server. This is enabled by default and allows VPN clients to avoid DNS leaks by sending all DNS requests to wg-access-server itself. WG_DNS_UPSTREAM --dns-upstream dns.upstream resolveconf autodetection or 1.1.1.1 The upstream DNS server to proxy DNS requests to. By default the host machine's resolveconf configuration is used to find it's upstream DNS server, otherwise 1.1.1.1 (cloudflare) is used. The Config File (config.yaml) \u00b6 Here's an example config file to get started with. loglevel : info storage : sqlite3:///data/db.sqlite3 wireguard : privateKey : \"<some-key>\" dns : upstream : - \"8.8.8.8\"","title":"Configuration"},{"location":"2-configuration/#configuration","text":"You can configure wg-access-server using environment variables, cli flags or a config file taking precedence over one another in that order. The default configuration should work out of the box if you're just looking to try it out. The only required configuration is an admin password and a wireguard private key. The admin password can be anything you like. You can generate a wireguard private key by following the official docs . TLDR: wg genkey The config file format is yaml and an example is provided below . Here's what you can configure: Environment Variable CLI Flag Config File Path Required Default (docker) Description WG_CONFIG --config The path to a wg-access-server config.yaml file WG_LOG_LEVEL --log-level logLevel info The global log level WG_ADMIN_USERNAME --admin-username adminUsername admin The admin account username WG_ADMIN_PASSWORD --admin-password adminPassword Yes The admin account password WG_PORT --port port 8000 The port the web ui will listen on (http) WG_EXTERNAL_HOST --external-host externalHost The external domain for the server (e.g. https://www.mydomain.com) WG_STORAGE --storage storage sqlite3:///data/db.sqlite3 A storage backend connection string. See storage docs WG_DISABLE_METADATA --disable-metadata disableMetadata false Turn off collection of device metadata logging. Includes last handshake time and RX/TX bytes only. WG_WIREGUARD_ENABLED --[no-]wireguard-enabled wireguard.enabled true Enable/disable the wireguard server. Useful for development on non-linux machines. WG_WIREGUARD_INTERFACE --wireguard-interface wireguard.interface wg0 The wireguard network interface name WG_WIREGUARD_PRIVATE_KEY --wireguard-private-key wireguard.privateKey Yes The wireguard private key. This value is required and must be stable. If this value changes all devices must re-register. WG_WIREGUARD_PORT --wireguard-port wireguard.port 51820 The wireguard server port (udp) WG_VPN_CIDR --vpn-cidr vpn.cidr 10.44.0.0/24 The VPN network range. VPN clients will be assigned IP addresses in this range. WG_VPN_GATEWAY_INTERFACE --vpn-gateway-interface vpn.gatewayInterface default gateway interface (e.g. eth0) The VPN gateway interface. VPN client traffic will be forwarded to this interface. WG_VPN_ALLOWED_IPS --vpn-allowed-ips vpn.allowedIPs 0.0.0.0/1, 128.0.0.0/1 Allowed IPs that clients may route through this VPN. This will be set in the client's WireGuard connection file and routing is also enforced by the server using iptables. WG_DNS_ENABLED --[no-]dns-enabled dns.enabled true Enable/disable the embedded DNS proxy server. This is enabled by default and allows VPN clients to avoid DNS leaks by sending all DNS requests to wg-access-server itself. WG_DNS_UPSTREAM --dns-upstream dns.upstream resolveconf autodetection or 1.1.1.1 The upstream DNS server to proxy DNS requests to. By default the host machine's resolveconf configuration is used to find it's upstream DNS server, otherwise 1.1.1.1 (cloudflare) is used.","title":"Configuration"},{"location":"2-configuration/#the-config-file-configyaml","text":"Here's an example config file to get started with. loglevel : info storage : sqlite3:///data/db.sqlite3 wireguard : privateKey : \"<some-key>\" dns : upstream : - \"8.8.8.8\"","title":"The Config File (config.yaml)"},{"location":"3-storage/","text":"Storage \u00b6 wg-access-server supports 4 storage backends. Backend Persistent Supports HA Use Case memory \u274c \u274c Local development sqlite3 \u2714\ufe0f \u274c Production - single instance deployments postgres \u2714\ufe0f \u2714\ufe0f Production - multi instance deployments mysql \u2714\ufe0f \u274c Production - single instance deployments Backends \u00b6 Memory \u00b6 This is the default backend if you're running the binary directly and haven't configured another storage backend. Data will be lost between restarts. Handy for development. Sqlite3 \u00b6 This is the default backend if you're running the docker container directly or using docker-compose. The database file will be written to /data/db.sqlite3 within the container by default. Sqlite3 is probably the simplest storage backend to get started with because it doesn't require any additional setup to be done. It should work out of the box and should be able to support a large number of users & devices. Example connection string: Relative path: sqlite3://path/to/db.sqlite3 Absolute path: sqlite3:///absolute/path/to/db.sqlite3 Postgres \u00b6 This backend requires an external Postgres database to be deployed. Postgres will support highly-available deployments of wg-access-server in the near future and is the recommended storage backend where possible. Example connection string: postgresql://user:password@localhost:5432/database?sslmode=disable Mysql \u00b6 This backend requires an external Mysql database to be deployed. Mysql flavours should be compatible. wg-access-server uses this golang driver if you want to check the compatibility of your favorite flavour. Example connection string: mysql://user:password@localhost:3306/database?ssl-mode=disabled File (removed) \u00b6 The file:// backend was deprecated in 0.3.0 and has been removed in 0.4.0 If you'd like to migrate your file:// storage to a supported backend you must use version 0.3.0 and then follow the migration guide below to migrate to a different storage backend. Note that the migration tool itself doesn't support the file:// backend on versions released after 0.3.0 . Migration Between Backends \u00b6 You can migrate your registered devices between backends using the wg-access-server migrate <src> <dest> command. The migrate command was added in v0.3.0 and is provided on a best effort level. As an open source project any community support here is warmly welcomed. Example: file:// to sqlite3:// \u00b6 If you're using the now deprecated file:// backend you can migrate to sqlite3:// like this: # after upgrading to place1/wg-access-server:v0.3.0 docker exec -it <container-name> wg-access-server migrate file:///data sqlite3:///data/db.sqlite3 If you need to do the above within a kubernetes deployment substitute docker exec with the equivalent kubectl exec command. The migrate command is non-destructive but it's always a good idea to take a backup of your data first! Example: sqlite3:// to postgresql:// \u00b6 First you'll need to make sure your postgres server is up and that you can connect to it from your wg-access-server container/pod/vm. wg-access-server migrate sqlite3:///data/db.sqlite3 postgresql://user:password@localhost:5432/database?sslmode = disable Remember to update your wg-access-server config to connect to postgres \ud83d\ude00","title":"Storage"},{"location":"3-storage/#storage","text":"wg-access-server supports 4 storage backends. Backend Persistent Supports HA Use Case memory \u274c \u274c Local development sqlite3 \u2714\ufe0f \u274c Production - single instance deployments postgres \u2714\ufe0f \u2714\ufe0f Production - multi instance deployments mysql \u2714\ufe0f \u274c Production - single instance deployments","title":"Storage"},{"location":"3-storage/#backends","text":"","title":"Backends"},{"location":"3-storage/#memory","text":"This is the default backend if you're running the binary directly and haven't configured another storage backend. Data will be lost between restarts. Handy for development.","title":"Memory"},{"location":"3-storage/#sqlite3","text":"This is the default backend if you're running the docker container directly or using docker-compose. The database file will be written to /data/db.sqlite3 within the container by default. Sqlite3 is probably the simplest storage backend to get started with because it doesn't require any additional setup to be done. It should work out of the box and should be able to support a large number of users & devices. Example connection string: Relative path: sqlite3://path/to/db.sqlite3 Absolute path: sqlite3:///absolute/path/to/db.sqlite3","title":"Sqlite3"},{"location":"3-storage/#postgres","text":"This backend requires an external Postgres database to be deployed. Postgres will support highly-available deployments of wg-access-server in the near future and is the recommended storage backend where possible. Example connection string: postgresql://user:password@localhost:5432/database?sslmode=disable","title":"Postgres"},{"location":"3-storage/#mysql","text":"This backend requires an external Mysql database to be deployed. Mysql flavours should be compatible. wg-access-server uses this golang driver if you want to check the compatibility of your favorite flavour. Example connection string: mysql://user:password@localhost:3306/database?ssl-mode=disabled","title":"Mysql"},{"location":"3-storage/#file-removed","text":"The file:// backend was deprecated in 0.3.0 and has been removed in 0.4.0 If you'd like to migrate your file:// storage to a supported backend you must use version 0.3.0 and then follow the migration guide below to migrate to a different storage backend. Note that the migration tool itself doesn't support the file:// backend on versions released after 0.3.0 .","title":"File (removed)"},{"location":"3-storage/#migration-between-backends","text":"You can migrate your registered devices between backends using the wg-access-server migrate <src> <dest> command. The migrate command was added in v0.3.0 and is provided on a best effort level. As an open source project any community support here is warmly welcomed.","title":"Migration Between Backends"},{"location":"3-storage/#example-file-to-sqlite3","text":"If you're using the now deprecated file:// backend you can migrate to sqlite3:// like this: # after upgrading to place1/wg-access-server:v0.3.0 docker exec -it <container-name> wg-access-server migrate file:///data sqlite3:///data/db.sqlite3 If you need to do the above within a kubernetes deployment substitute docker exec with the equivalent kubectl exec command. The migrate command is non-destructive but it's always a good idea to take a backup of your data first!","title":"Example: file:// to sqlite3://"},{"location":"3-storage/#example-sqlite3-to-postgresql","text":"First you'll need to make sure your postgres server is up and that you can connect to it from your wg-access-server container/pod/vm. wg-access-server migrate sqlite3:///data/db.sqlite3 postgresql://user:password@localhost:5432/database?sslmode = disable Remember to update your wg-access-server config to connect to postgres \ud83d\ude00","title":"Example: sqlite3:// to postgresql://"},{"location":"4-auth/","text":"Authentication \u00b6 Authentication is pluggable in wg-access-server. Community contributions are welcome for supporting new authentication backends. If you're just getting started you can skip over this section and rely on the default admin account instead. If your authentication system is not yet supported and you aren't quite ready to contribute you could try using a project like dex or SaaS provider like Auth0 which supports a wider variety of authentication protocols. wg-access-server can happily be an OpenID Connect client to a larger solution like this. The following authentication backends are currently supported: Backend Use Case Notes Basic Auth Deployments with a static list of users. Simple and great for self-hosters and home use-cases The wg-access-server admin account is powered by this backend OpenID Connect For delegating authentication to an existing identity solution Gitlab For delegating authentication to gitlab. Supports self-hosted Gitlab. Configuration \u00b6 Currently authentication providers are only configurable via the wg-access-server config file (config.yaml). Below is an annotated example config section that can be used as a starting point. # Configure zero or more authentication backends auth : # HTTP Basic Authentication basic : # Users is a list of htpasswd encoded username:password pairs # supports BCrypt, Sha, Ssha, Md5 # You can create a user using \"htpasswd -nB <username>\" users : [] oidc : # A name for the backend (can be anything you want) name : \"My OIDC Backend\" # Should point to the OIDC Issuer (excluding /.well-known/openid-configuration) issuer : \"https://identity.example.com\" # Your OIDC client credentials which would be provided by your OIDC provider clientID : \"<client-id>\" clientSecret : \"<client-secret>\" # List of scopes to request defaults to [\"openid\"] scopes : - openid # The full redirect URL # The path can be almost anything as long as it doesn't # conflict with a path that the web UI uses. # /callback is recommended. redirectURL : \"https://wg-access-server.example.com/callback\" # You can optionally restrict access to users with an email address # that matches an allowed domain. # If empty or omitted then all email domains will be allowed. emailDomains : - example.com # This is an advanced feature that allows you to define # OIDC claim mapping expressions. # This feature is used to define wg-access-server admins # based off a claim in your OIDC token # See https://github.com/Knetic/govaluate/blob/9aa49832a739dcd78a5542ff189fb82c3e423116/MANUAL.md for how to write rules claimMapping : admin : \"'WireguardAdmins' in group_membership\" gitlab : name : \"My Gitlab Backend\" baseURL : \"https://mygitlab.example.com\" clientID : \"<client-id>\" clientSecret : \"<client-secret>\" redirectURL : \"https:///wg-access-server.example.com/callback\" emailDomains : - example.com","title":"Authentication"},{"location":"4-auth/#authentication","text":"Authentication is pluggable in wg-access-server. Community contributions are welcome for supporting new authentication backends. If you're just getting started you can skip over this section and rely on the default admin account instead. If your authentication system is not yet supported and you aren't quite ready to contribute you could try using a project like dex or SaaS provider like Auth0 which supports a wider variety of authentication protocols. wg-access-server can happily be an OpenID Connect client to a larger solution like this. The following authentication backends are currently supported: Backend Use Case Notes Basic Auth Deployments with a static list of users. Simple and great for self-hosters and home use-cases The wg-access-server admin account is powered by this backend OpenID Connect For delegating authentication to an existing identity solution Gitlab For delegating authentication to gitlab. Supports self-hosted Gitlab.","title":"Authentication"},{"location":"4-auth/#configuration","text":"Currently authentication providers are only configurable via the wg-access-server config file (config.yaml). Below is an annotated example config section that can be used as a starting point. # Configure zero or more authentication backends auth : # HTTP Basic Authentication basic : # Users is a list of htpasswd encoded username:password pairs # supports BCrypt, Sha, Ssha, Md5 # You can create a user using \"htpasswd -nB <username>\" users : [] oidc : # A name for the backend (can be anything you want) name : \"My OIDC Backend\" # Should point to the OIDC Issuer (excluding /.well-known/openid-configuration) issuer : \"https://identity.example.com\" # Your OIDC client credentials which would be provided by your OIDC provider clientID : \"<client-id>\" clientSecret : \"<client-secret>\" # List of scopes to request defaults to [\"openid\"] scopes : - openid # The full redirect URL # The path can be almost anything as long as it doesn't # conflict with a path that the web UI uses. # /callback is recommended. redirectURL : \"https://wg-access-server.example.com/callback\" # You can optionally restrict access to users with an email address # that matches an allowed domain. # If empty or omitted then all email domains will be allowed. emailDomains : - example.com # This is an advanced feature that allows you to define # OIDC claim mapping expressions. # This feature is used to define wg-access-server admins # based off a claim in your OIDC token # See https://github.com/Knetic/govaluate/blob/9aa49832a739dcd78a5542ff189fb82c3e423116/MANUAL.md for how to write rules claimMapping : admin : \"'WireguardAdmins' in group_membership\" gitlab : name : \"My Gitlab Backend\" baseURL : \"https://mygitlab.example.com\" clientID : \"<client-id>\" clientSecret : \"<client-secret>\" redirectURL : \"https:///wg-access-server.example.com/callback\" emailDomains : - example.com","title":"Configuration"},{"location":"deployment/1-docker/","text":"Docker \u00b6 TL;DR; \u00b6 Here's a one-liner to run wg-access-server: docker run --rm -it --cap-add NET_ADMIN \\ --device /dev/net/tun:/dev/net/tun \\ -p 8000 :8000/tcp \\ -p 51820 :51820/udp \\ place1/wg-access-server","title":"Docker"},{"location":"deployment/1-docker/#docker","text":"","title":"Docker"},{"location":"deployment/1-docker/#tldr","text":"Here's a one-liner to run wg-access-server: docker run --rm -it --cap-add NET_ADMIN \\ --device /dev/net/tun:/dev/net/tun \\ -p 8000 :8000/tcp \\ -p 51820 :51820/udp \\ place1/wg-access-server","title":"TL;DR;"},{"location":"deployment/2-docker-compose/","text":"Docker Compose \u00b6 You can run wg-access-server using the following example docker Docker Compose file. Checkout the configuration docs to learn how wg-access-server can be configured. version : \"3.0\" services : wg-access-server : # to build the docker image from the source # build: # dockerfile: Dockerfile # context: . image : place1/wg-access-server container_name : wg-access-server cap_add : - NET_ADMIN volumes : - \"wg-access-server-data:/data\" # - \"./config.yaml:/config.yaml\" # if you have a custom config file environment : - \"WG_ADMIN_USERNAME=admin\" - \"WG_ADMIN_PASSWORD=${WG_ADMIN_PASSWORD:?\\n\\nplease set the WG_ADMIN_PASSWORD environment variable:\\n export WG_ADMIN_PASSWORD=example\\n}\" - \"WG_WIREGUARD_PRIVATE_KEY=${WG_WIREGUARD_PRIVATE_KEY:?\\n\\nplease set the WG_WIREGUARD_PRIVATE_KEY environment variable:\\n export WG_WIREGUARD_PRIVATE_KEY=$(wg genkey)\\n}\" ports : - \"8000:8000/tcp\" - \"51820:51820/udp\" devices : - \"/dev/net/tun:/dev/net/tun\" # shared volumes with the host volumes : wg-access-server-data : driver : local","title":"Docker Compose"},{"location":"deployment/2-docker-compose/#docker-compose","text":"You can run wg-access-server using the following example docker Docker Compose file. Checkout the configuration docs to learn how wg-access-server can be configured. version : \"3.0\" services : wg-access-server : # to build the docker image from the source # build: # dockerfile: Dockerfile # context: . image : place1/wg-access-server container_name : wg-access-server cap_add : - NET_ADMIN volumes : - \"wg-access-server-data:/data\" # - \"./config.yaml:/config.yaml\" # if you have a custom config file environment : - \"WG_ADMIN_USERNAME=admin\" - \"WG_ADMIN_PASSWORD=${WG_ADMIN_PASSWORD:?\\n\\nplease set the WG_ADMIN_PASSWORD environment variable:\\n export WG_ADMIN_PASSWORD=example\\n}\" - \"WG_WIREGUARD_PRIVATE_KEY=${WG_WIREGUARD_PRIVATE_KEY:?\\n\\nplease set the WG_WIREGUARD_PRIVATE_KEY environment variable:\\n export WG_WIREGUARD_PRIVATE_KEY=$(wg genkey)\\n}\" ports : - \"8000:8000/tcp\" - \"51820:51820/udp\" devices : - \"/dev/net/tun:/dev/net/tun\" # shared volumes with the host volumes : wg-access-server-data : driver : local","title":"Docker Compose"},{"location":"deployment/3-kubernetes/","text":"Helm Chart \u00b6 Installing the Chart \u00b6 To install the chart with the release name my-release : $ helm install my-release --repo https://place1.github.io/wg-access-server wg-access-server The command deploys wg-access-server on the Kubernetes cluster in the default configuration. The configuration section lists the parameters that can be configured during installation. By default an in-memory wireguard private key will be generated and devices will not persist between pod restarts. Uninstalling the Chart \u00b6 To uninstall/delete the my-release deployment: $ helm delete my-release The command removes all the Kubernetes components associated with the chart and deletes the release. Example values.yaml \u00b6 config : wireguard : externalHost : \"<loadbalancer-ip>\" # wg access server is an http server without TLS. Exposing it via a loadbalancer is NOT secure! # Uncomment the following section only if you are running on private network or simple testing. # A much better option would be TLS terminating ingress controller or reverse-proxy. # web: # service: # type: \"LoadBalancer\" # loadBalancerIP: \"<loadbalancer-ip>\" wireguard : config : privateKey : \"<wireguard-private-key>\" service : type : \"LoadBalancer\" loadBalancerIP : \"<loadbalancer-ip>\" persistence : enabled : true ingress : enabled : true hosts : [ \"vpn.example.com\" ] tls : - hosts : [ \"vpn.example.com\" ] secretName : \"tls-wg-access-server\" All Configuration \u00b6 Key Type Default Description config object {} inline wg-access-server config (config.yaml) web.service.type string \"ClusterIP\" wireguard.config.privateKey string \"\" A wireguard private key. You can generate one using $ wg genkey wireguard.service.type string \"ClusterIP\" ingress.enabled bool false ingress.hosts string nil ingress.tls list [] ingress.annotations object {} persistence.enabled bool false persistence.existingClaim string \"\" Use existing PVC claim for persistence instead persistence.size string \"100Mi\" persistence.subPath string \"\" persistence.annotations object {} persistence.accessModes[0] string \"ReadWriteOnce\" strategy.type string \"Recreate\" resources object {} pod cpu/memory resource requests and limits nameOverride string \"\" fullnameOverride string \"\" affinity object {} nodeSelector object {} tolerations list [] image.pullPolicy string \"IfNotPresent\" image.repository string \"place1/wg-access-server\" imagePullSecrets list []","title":"Helm Chart"},{"location":"deployment/3-kubernetes/#helm-chart","text":"","title":"Helm Chart"},{"location":"deployment/3-kubernetes/#installing-the-chart","text":"To install the chart with the release name my-release : $ helm install my-release --repo https://place1.github.io/wg-access-server wg-access-server The command deploys wg-access-server on the Kubernetes cluster in the default configuration. The configuration section lists the parameters that can be configured during installation. By default an in-memory wireguard private key will be generated and devices will not persist between pod restarts.","title":"Installing the Chart"},{"location":"deployment/3-kubernetes/#uninstalling-the-chart","text":"To uninstall/delete the my-release deployment: $ helm delete my-release The command removes all the Kubernetes components associated with the chart and deletes the release.","title":"Uninstalling the Chart"},{"location":"deployment/3-kubernetes/#example-valuesyaml","text":"config : wireguard : externalHost : \"<loadbalancer-ip>\" # wg access server is an http server without TLS. Exposing it via a loadbalancer is NOT secure! # Uncomment the following section only if you are running on private network or simple testing. # A much better option would be TLS terminating ingress controller or reverse-proxy. # web: # service: # type: \"LoadBalancer\" # loadBalancerIP: \"<loadbalancer-ip>\" wireguard : config : privateKey : \"<wireguard-private-key>\" service : type : \"LoadBalancer\" loadBalancerIP : \"<loadbalancer-ip>\" persistence : enabled : true ingress : enabled : true hosts : [ \"vpn.example.com\" ] tls : - hosts : [ \"vpn.example.com\" ] secretName : \"tls-wg-access-server\"","title":"Example values.yaml"},{"location":"deployment/3-kubernetes/#all-configuration","text":"Key Type Default Description config object {} inline wg-access-server config (config.yaml) web.service.type string \"ClusterIP\" wireguard.config.privateKey string \"\" A wireguard private key. You can generate one using $ wg genkey wireguard.service.type string \"ClusterIP\" ingress.enabled bool false ingress.hosts string nil ingress.tls list [] ingress.annotations object {} persistence.enabled bool false persistence.existingClaim string \"\" Use existing PVC claim for persistence instead persistence.size string \"100Mi\" persistence.subPath string \"\" persistence.annotations object {} persistence.accessModes[0] string \"ReadWriteOnce\" strategy.type string \"Recreate\" resources object {} pod cpu/memory resource requests and limits nameOverride string \"\" fullnameOverride string \"\" affinity object {} nodeSelector object {} tolerations list [] image.pullPolicy string \"IfNotPresent\" image.repository string \"place1/wg-access-server\" imagePullSecrets list []","title":"All Configuration"}]}